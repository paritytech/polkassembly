"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rxjs = require("rxjs");

var _util = require("@polkadot/util");

var _observable = _interopRequireDefault(require("../observable"));

// Copyright 2017-2020 @polkadot/ui-keyring authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
let hasCalledInitOptions = false;

const sortByName = (a, b) => {
  const valueA = a.option.name;
  const valueB = b.option.name;
  return valueA.localeCompare(valueB);
};

const sortByCreated = (a, b) => {
  const valueA = a.json.meta.whenCreated || 0;
  const valueB = b.json.meta.whenCreated || 0;

  if (valueA < valueB) {
    return 1;
  }

  if (valueA > valueB) {
    return -1;
  }

  return 0;
};

class KeyringOption {
  constructor() {
    this.optionsSubject = new _rxjs.BehaviorSubject(this.emptyOptions());
  }

  createOptionHeader(name) {
    return {
      name,
      key: "header-".concat(name.toLowerCase()),
      value: null
    };
  }

  init(keyring) {
    (0, _util.assert)(!hasCalledInitOptions, 'Unable to initialise options more than once');

    _observable.default.subscribe(() => {
      const opts = this.emptyOptions();
      this.addAccounts(keyring, opts);
      this.addAddresses(keyring, opts);
      this.addContracts(keyring, opts);
      opts.address = this.linkItems({
        Addresses: opts.address,
        Recent: opts.recent
      });
      opts.account = this.linkItems({
        Accounts: opts.account,
        Development: opts.testing
      });
      opts.contract = this.linkItems({
        Contracts: opts.contract
      });
      opts.all = [].concat(opts.account, opts.address);
      opts.allPlus = [].concat(opts.account, opts.address, opts.contract);
      this.optionsSubject.next(opts);
    });

    hasCalledInitOptions = true;
  }

  linkItems(items) {
    return Object.keys(items).reduce((result, header) => {
      const options = items[header];
      return result.concat(options.length ? [this.createOptionHeader(header)] : [], options);
    }, []);
  }

  addAccounts(keyring, options) {
    const available = keyring.accounts.subject.getValue();
    Object.values(available).sort(sortByName).forEach(({
      json: {
        meta: {
          isTesting = false
        }
      },
      option
    }) => {
      if (!isTesting) {
        options.account.push(option);
      } else {
        options.testing.push(option);
      }
    });
  }

  addAddresses(keyring, options) {
    const available = keyring.addresses.subject.getValue();
    Object.values(available).filter(({
      json
    }) => !!json.meta.isRecent).sort(sortByCreated).forEach(({
      option
    }) => {
      options.recent.push(option);
    });
    Object.values(available).filter(({
      json
    }) => !json.meta.isRecent).sort(sortByName).forEach(({
      option
    }) => {
      options.address.push(option);
    });
  }

  addContracts(keyring, options) {
    const available = keyring.contracts.subject.getValue();
    Object.values(available).sort(sortByName).forEach(({
      option
    }) => {
      options.contract.push(option);
    });
  }

  emptyOptions() {
    return {
      account: [],
      address: [],
      contract: [],
      all: [],
      allPlus: [],
      recent: [],
      testing: []
    };
  }

}

const keyringOptionInstance = new KeyringOption();
var _default = keyringOptionInstance;
exports.default = _default;