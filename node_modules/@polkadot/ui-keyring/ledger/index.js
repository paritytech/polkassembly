"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.LEDGER_DEFAULT_INDEX = exports.LEDGER_DEFAULT_CHANGE = exports.LEDGER_DEFAULT_ACCOUNT = void 0;

var _ledgerPolkadot = _interopRequireDefault(require("ledger-polkadot"));

var _util = require("@polkadot/util");

var _transportsNode = _interopRequireDefault(require("./transportsNode"));

var _transportsWeb = _interopRequireDefault(require("./transportsWeb"));

// Copyright 2017-2020 @polkadot/ui-keyring authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
const LEDGER_DEFAULT_ACCOUNT = 0x80000000;
exports.LEDGER_DEFAULT_ACCOUNT = LEDGER_DEFAULT_ACCOUNT;
const LEDGER_DEFAULT_CHANGE = 0x80000000;
exports.LEDGER_DEFAULT_CHANGE = LEDGER_DEFAULT_CHANGE;
const LEDGER_DEFAULT_INDEX = 0x80000000;
exports.LEDGER_DEFAULT_INDEX = LEDGER_DEFAULT_INDEX;
const SUCCESS_CODE = 0x9000;

const transports = _transportsNode.default.concat(_transportsWeb.default); // A very basic wrapper for a ledger app -
//  - it connects automatically, creating an app as required
//  - Promises return errors (instead of wrapper errors)


class Ledger {
  constructor(type) {
    this.app = null;
    this.type = void 0;
    (0, _util.assert)(['hid', 'u2f', 'webusb'].includes(type), "Unsupported transport ".concat(type));
    this.type = type;
  }

  async getApp() {
    if (!this.app) {
      const def = transports.find(({
        type
      }) => type === this.type);
      (0, _util.assert)(def, "Unable to find a transport for ".concat(this.type));
      const transport = await def.create();
      this.app = new _ledgerPolkadot.default(transport);
    }

    return this.app;
  }

  async withApp(fn) {
    try {
      const app = await this.getApp();
      return await fn(app);
    } catch (error) {
      this.app = null;
      throw error;
    }
  }

  async wrapError(promise) {
    const result = await promise;
    (0, _util.assert)(result.return_code === SUCCESS_CODE, result.error_message);
    return result;
  }

  async getAddress(confirm = false, account = LEDGER_DEFAULT_ACCOUNT, change = LEDGER_DEFAULT_CHANGE, addressIndex = LEDGER_DEFAULT_INDEX) {
    return this.withApp(async app => {
      const {
        address,
        pubKey
      } = await this.wrapError(app.getAddress(account, change, addressIndex, confirm));
      return {
        address,
        publicKey: "0x".concat(pubKey)
      };
    });
  }

  async getVersion() {
    return this.withApp(async app => {
      const {
        device_locked: isLocked,
        major,
        minor,
        patch,
        test_mode: isTestMode
      } = await this.wrapError(app.getVersion());
      return {
        isLocked,
        isTestMode,
        version: [major, minor, patch]
      };
    });
  }

  async sign(message, account = LEDGER_DEFAULT_ACCOUNT, change = LEDGER_DEFAULT_CHANGE, addressIndex = LEDGER_DEFAULT_INDEX) {
    return this.withApp(async app => {
      const buffer = (0, _util.u8aToBuffer)(message);
      const {
        signature
      } = await this.wrapError(app.sign(account, change, addressIndex, buffer));
      return {
        signature: (0, _util.u8aToHex)((0, _util.bufferToU8a)(signature))
      };
    });
  }

}

exports.default = Ledger;